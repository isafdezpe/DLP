<!DOCTYPE html>
<html>
<head>
<title>Acciones en ANTLR.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: "Segoe WPC", "Segoe UI", "SFUIText-Light", "HelveticaNeue-Light", sans-serif, "Droid Sans Fallback";
	font-size: 14px;
	padding: 0 12px;
	line-height: 22px;
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}


body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	color: #4080D0;
	text-decoration: none;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

h1 code,
h2 code,
h3 code,
h4 code,
h5 code,
h6 code {
	font-size: inherit;
	line-height: auto;
}

a:hover {
	color: #4080D0;
	text-decoration: underline;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left: 5px solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 14px;
	line-height: 19px;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

.mac code {
	font-size: 12px;
	line-height: 18px;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

/** Theming */

.vscode-light,
.vscode-light pre code {
	color: rgb(30, 30, 30);
}

.vscode-dark,
.vscode-dark pre code {
	color: #DDD;
}

.vscode-high-contrast,
.vscode-high-contrast pre code {
	color: white;
}

.vscode-light code {
	color: #A31515;
}

.vscode-dark code {
	color: #D7BA7D;
}

.vscode-light pre:not(.hljs),
.vscode-light code > div {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre:not(.hljs),
.vscode-dark code > div {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre:not(.hljs),
.vscode-high-contrast code > div {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	   border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

.vscode-light blockquote,
.vscode-dark blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.vscode-high-contrast blockquote {
	background: transparent;
	border-color: #fff;
}
</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family:  "Meiryo", "Segoe WPC", "Segoe UI", "SFUIText-Light", "HelveticaNeue-Light", sans-serif, "Droid Sans Fallback";
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>


</head>
<body>

<h1 id="acceso-a-atributos-en-las-acciones-de-antlr">Acceso a Atributos en las Acciones de ANTLR</h1>
<blockquote>
<p>Creado por <em>Raúl Izquierdo Castanedo</em> para la asignatura de <em>Diseño de Lenguajes de Programación</em> de la <em>Universidad de Oviedo</em>.</p>
</blockquote>
<ul>
<li><a href="#acceso-a-atributos-en-las-acciones-de-antlr">Acceso a Atributos en las Acciones de ANTLR</a>
<ul>
<li><a href="#el-objeto-contexto-de-una-regla">El Objeto Contexto de una Regla</a></li>
<li><a href="#acceso-a-atributos-de-la-propia-regla">Acceso a Atributos de la propia Regla</a></li>
<li><a href="#acceso-a-los-atributos-de-los-s%C3%ADmbolos-en-el-consecuente-de-la-regla">Acceso a los Atributos de los Símbolos en el Consecuente de la Regla</a>
<ul>
<li><a href="#acceso-a-atributos-de-s%C3%ADmbolos-terminales">Acceso a Atributos de Símbolos Terminales</a>
<ul>
<li><a href="#terminales-definidos">Terminales Definidos</a></li>
<li><a href="#terminales-an%C3%B3nimos">Terminales Anónimos</a></li>
<li><a href="#terminales-opcionales">Terminales Opcionales</a></li>
<li><a href="#terminales-repetidos-en-la-regla">Terminales Repetidos en la Regla</a>
<ul>
<li><a href="#opci%C3%B3n-1-sub%C3%ADndices">Opción 1. Subíndices</a></li>
<li><a href="#opci%C3%B3n-2-etiquetas">Opción 2. Etiquetas</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#acceso-a-atributos-de-s%C3%ADmbolos-no-terminales">Acceso a Atributos de Símbolos No Terminales</a>
<ul>
<li><a href="#no-terminales-opcionales">No-Terminales Opcionales</a></li>
<li><a href="#no-terminales-repetidos-en-la-regla">No-Terminales Repetidos en la Regla</a>
<ul>
<li><a href="#opci%C3%B3n-1-acceso-con-sub%C3%ADndices">Opción 1. Acceso con Subíndices</a></li>
<li><a href="#opci%C3%B3n-2-acceso-con-etiquetas">Opción 2. Acceso con Etiquetas</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#creaci%C3%B3n-de-listas-java-en-antlr">Creación de Listas Java en ANTLR</a></li>
</ul>
</li>
</ul>
<h2 id="el-objeto-contexto-de-una-regla">El Objeto Contexto de una Regla</h2>
<p>Para una regla de nombre <code>abc</code>, ANTLR crearía:</p>
<ol>
<li>Una clase de nombre <code>AbcContext</code> (derivada de la clase común para todas las reglas llamada <code>ParserRuleContext</code>). Este objeto, denominado el <strong>contexto</strong> de <em>abc</em>, será el que se utilice para guardar toda la información necesaria durante la ejecución de la regla y será también el que, al acabar la misma, se devuelva como valor de retorno.</li>
<li>Un método en el Parser de nombre <code>abc()</code> que devuelve un objeto de la clase anterior.</li>
</ol>
<p>Por ejemplo, para el no-terminal <em>expr</em></p>
<pre class="hljs"><code><div>expr: ... ;
</div></code></pre>
<p>se crea lo siguiente:</p>
<pre class="hljs"><code><div>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExprContext</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ParserRuleContext</span> </span>{
    ...
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GrammarParser</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> ExprContext <span class="hljs-title">expr</span><span class="hljs-params">()</span>  </span>{
        ExprContext ctx = <span class="hljs-keyword">new</span> ExprContext(...);
        ...

        <span class="hljs-keyword">return</span> ctx;
    }
    ...
}
</div></code></pre>
<p>El contexto contiene (entre otras cosas):</p>
<ul>
<li>El atributo donde se dejará el valor de retorno (el habitual <code>ast</code>).</li>
<li>Las variables locales de las reglas.</li>
<li>Los objetos asociados a todos los símbolos del consecuente (parte derecha) de la regla: sus Tokens (si son terminales) o los contextos que a su vez éstos devuelvan (si son no-terminales).</li>
</ul>
<p>Por ejemplo, una regla como la siguiente:</p>
<pre class="hljs"><code><div>abc returns[String val] locals[int cont, float f]
	: IDENT b;
</div></code></pre>
<p>Generaría (simplificando) un contexto llamado <em>AContext</em>:</p>
<pre class="hljs"><code><div>class AbcContext extends ParserRuleContext {
    public String val;      // Retorno
    public int cont;        // Local 1
    public float f;         // Local 2
    public Token IDENT;     // Hijo 1
    public BContext b;      // Hijo 2
}
</div></code></pre>
<h2 id="acceso-a-atributos-de-la-propia-regla">Acceso a Atributos de la propia Regla</h2>
<p>Para acceder a los atributos del contexto actual (<code>AbcContext</code>), basta con poner directamente <em>$atributo</em>:</p>
<pre class="hljs"><code><div>abc returns[String val] locals[int cont, float f]
	: IDENT b { $val = &quot;adios&quot;; $cont = 5; }
	;
</div></code></pre>
<p>Si se quiere acceder al objeto <em>contexto</em> completo (al objeto <code>AbcContext</code>), hay que poner <em>$ctx</em>.</p>
<pre class="hljs"><code><div>abc returns[String val] locals[int cont, float f]
	: IDENT b { System.out.println($ctx); }
	;
</div></code></pre>
<p>De hecho, cuando se accede a los atributos, ANTLR internamente está poniendo <em>ctx</em> antes de cada uno. De hecho, las dos siguientes reglas son idénticas:</p>
<pre class="hljs"><code><div>abc returns[String val] locals[int cont, float f]
	: IDENT b { $ctx.val = &quot;adios&quot;; $ctx.cont = 5; }
	;

abc returns[String val] locals[int cont, float f]
	: IDENT b { $val = &quot;adios&quot;; $cont = 5; }  // ANTLR pone los &quot;ctx.&quot; por nosostros
	;
</div></code></pre>
<h2 id="acceso-a-los-atributos-de-los-s%C3%ADmbolos-en-el-consecuente-de-la-regla">Acceso a los Atributos de los Símbolos en el Consecuente de la Regla</h2>
<p>En vez de acceder a los atributos de la propia regla, ahora se tratará cómo acceder a los atributos de los símbolos que están en la parte derecha de la regla (los símbolos <em>hijos</em> de la regla).</p>
<p>La forma de acceder (y el valor obtenido), depende de que el símbolo a consultar sea terminal o no-terminal.</p>
<h3 id="acceso-a-atributos-de-s%C3%ADmbolos-terminales">Acceso a Atributos de Símbolos Terminales</h3>
<h4 id="terminales-definidos">Terminales Definidos</h4>
<pre class="hljs"><code><div>a: IDENT { System.out.println($IDENT); } // Objeto Token
</div></code></pre>
<p>La notación <em>$símbolo</em>, siendo el símbolo un terminal, devuelve un objeto la clase Token (y, por tanto, se pueden invocar sobre él todos los métodos de esta clase). El método más usado de dicha clase será <code>getText()</code> para obtener el lexema del token. Por ello, ANTLR permite el atajo de poner <code>$símbolo.text</code> y él lo sustituirá por <code>$símbolo.getText()</code>.</p>
<pre class="hljs"><code><div>a: IDENT { System.out.println($IDENT.text); } // Lexema (string). Equivale a `$IDENT.getText()`
</div></code></pre>
<p>Aunque se incluyen los demás casos por presentar todas las opciones, el ejemplo anterior <em>será lo que se use la inmensa mayoría de las veces</em> para acceder a un <em>terminal</em>. De hecho, se podría pasar ya al apartado de <a href="#acceso-a-atributos-de-s%C3%ADmbolos-no-terminales">Acceso a Atributos de Símbolos No Terminales</a>.</p>
<h4 id="terminales-an%C3%B3nimos">Terminales Anónimos</h4>
<p>Para acceder a terminales anónimos (definidos entre comillas simples), hay que usar etiquetas. En este caso, se utiliza la etiqueta <code>tk</code>:</p>
<pre class="hljs"><code><div>a: tk='print' { System.out.println($tk.text); }
</div></code></pre>
<h4 id="terminales-opcionales">Terminales Opcionales</h4>
<p>Si el token es opcional (operador <code>?</code>), puede no aparecer en la entrada. Si esto ocurre, al acceder a él se obtendrá null.</p>
<pre class="hljs"><code><div>a: IDENT? INT_CONSTANT { System.out.println($IDENT); }	// $IDENT == null si no aparece en la entrada
</div></code></pre>
<h4 id="terminales-repetidos-en-la-regla">Terminales Repetidos en la Regla</h4>
<p>Si hay varios terminales con el mismo nombre, si se pone dicho nombre sólo se accederá al último de ellos.</p>
<pre class="hljs"><code><div>a: IDENT IDENT { System.out.println($IDENT); } // El segundo
</div></code></pre>
<p>Para acceder a cualquier otro token, hay dos opciones: subíndices y etiquetas.</p>
<h5 id="opci%C3%B3n-1-sub%C3%ADndices">Opción 1. Subíndices</h5>
<p>Los subíndices empiezan en 0.</p>
<pre class="hljs"><code><div>a: IDENT IDENT { System.out.println($IDENT(0).getText()); }
</div></code></pre>
<p>En este caso, ANTLR no permite usar el atajo <code>$IDENT(0).text</code> para acceder al lexema, por lo que hay que poner la expresión completa <code>$IDENT(0).getText()</code>.</p>
<h5 id="opci%C3%B3n-2-etiquetas">Opción 2. Etiquetas</h5>
<p>La alternativa a usar subíndices es usar etiquetas que identifiquen el terminal al que nos referimos:</p>
<pre class="hljs"><code><div>a: id1=IDENT id2=IDENT { System.out.println($id1.text); }
</div></code></pre>
<p>En este caso, se puede volver a usar el atajo <code>$id1.text</code> para obtener el lexema.</p>
<h3 id="acceso-a-atributos-de-s%C3%ADmbolos-no-terminales">Acceso a Atributos de Símbolos No Terminales</h3>
<p>Pasamos ahora a los hijos no-terminales. Cuando el símbolo <code>b</code> es un no-terminal, la llamada a <code>b()</code> devuelve su contexto. Para acceder a dicho objeto, siendo coherente con cómo se accede a los tokens, podría parecer que debería poder accederse mediante <em>$b</em>. Sin embargo, esto no es así (por algún motivo que ANTLR no especifica):</p>
<pre class="hljs"><code><div>a: b { System.out.println($b); }	// Error. Requiere acceder a un atributo
</div></code></pre>
<p>Para acceder a dicho contexto, hay que poner <code>$b.ctx</code> (que sí se puede poner) o bien, lo que será más habitual, poner ya directamente algún atributo de dicho contexto (ANTLR ya añadirá el prefijo <em>ctx</em> a dicho atributo). Ejemplo:</p>
<pre class="hljs"><code><div>a: b { System.out.println($b.val); }
    // Equivaldría a $b.ctx.val (que no se puede poner)
    ;

b returns[String val]
    : IDENT { $val = $IDENT.text; }
    ;
</div></code></pre>
<p>En resumen:</p>
<table>
<thead>
<tr>
<th>Para...</th>
<th>se puede poner</th>
<th>no se puede poner</th>
</tr>
</thead>
<tbody>
<tr>
<td>Acceder a un atributo de un símbolo</td>
<td><code>$b.&lt;atributo&gt;</code></td>
<td><code>$b.ctx.&lt;atributo&gt;</code></td>
</tr>
<tr>
<td>Para acceder al objeto contexto (el que tiene todos los atributos)</td>
<td><code>$b.ctx</code></td>
<td><code>$b</code></td>
</tr>
</tbody>
</table>
<p>Aunque a continuación se incluyen los demás casos por presentar todas las opciones, el ejemplo anterior <em>será lo que se use la inmensa mayoría de las veces</em> para acceder a un <em>no-terminal</em>.</p>
<h4 id="no-terminales-opcionales">No-Terminales Opcionales</h4>
<p>Si el hijo es opcional (operador <code>?</code>), puede no aparecer en la entrada. Si esto ocurre, al acceder a su contexto se obtendrá null. Se podrá así saber si apareció o no.</p>
<pre class="hljs"><code><div>a: b? INT_CONSTANT { System.out.println($b.ctx == null); }
</div></code></pre>
<p>Nótese que, en una inconsistencia más de ANTLR, a diferencia de cómo se hacia con los terminales y como se vió en el apartado anterior, aquí no se puede hacer:</p>
<pre class="hljs"><code><div>a: b? INT_CONSTANT { System.out.println($b == null); };
</div></code></pre>
<h4 id="no-terminales-repetidos-en-la-regla">No-Terminales Repetidos en la Regla</h4>
<p>Si hay varios no-terminales con el mismo nombre, mediante dicho nombre sólo se accede al último de ellos:</p>
<pre class="hljs"><code><div>a: b b { System.out.println($b.val); } // La segunda b
	;

b returns[String val]
	: IDENT { $val = $IDENT.text; }
	;
</div></code></pre>
<p>Para acceder a cualquier otro token, hay dos opciones: subíndices y etiquetas.</p>
<h5 id="opci%C3%B3n-1-acceso-con-sub%C3%ADndices">Opción 1. Acceso con Subíndices</h5>
<p>Los subíndices empiezan en 0.</p>
<pre class="hljs"><code><div>a: b b { System.out.println($ctx.b(0).val); }; // La primera b
</div></code></pre>
<p>Nótese que, a diferencia de con los terminales, es obligatorio poner <em>$ctx</em> antes del nombre del símbolo.</p>
<h5 id="opci%C3%B3n-2-acceso-con-etiquetas">Opción 2. Acceso con Etiquetas</h5>
<p>Usar etiquetas. Este caso si que es igual que con los terminales.</p>
<pre class="hljs"><code><div>a: id1=b id2=b { System.out.println($id1.val); };
</div></code></pre>
<h2 id="creaci%C3%B3n-de-listas-java-en-antlr">Creación de Listas Java en ANTLR</h2>
<p>A continuación se muestran las acciones asociadas que hay que añadir a los patrones BNF.</p>
<h3 id="versi%C3%B3n-simple">Versión Simple</h3>
<p>Se crea a mano una lista y se añade la acción que va insertando cada elemento. El siguiente ejemplo muestra cómo se crearía una lista de sentencias:</p>
<pre class="hljs"><code><div>start returns[Program ast]
	: 'CODE' sentences { $ast = new Program($sentences.list); }
	;

sentences returns[List&lt;Sentence&gt; list = new ArrayList&lt;Sentence&gt;()]
	: (sentence { $list.add($sentence.ast); })*
	;

sentence returns[Sentence ast]
	: 'print' expr ';'	{ $ast = new Print($expr.ast); }
	| expr '=' expr ';'	{ $ast = new Assignment($ctx.expr(0).ast, $ctx.expr(1).ast); }
	;
</div></code></pre>
<h3 id="versi%C3%B3n-avanzada">Versión Avanzada</h3>
<p>Al usar la opción de etiquetar los símbolos, se puede añadir un '+' antes del signo '='. De esta manera, ANTLR crea una lista del tipo adecuado (Token si es un terminal o su clase Context si es un no-terminal) y añade a la misma el token/contexto de dicho símbolo:</p>
<p>Ejemplo con terminales:</p>
<pre class="hljs"><code><div>a: l+=IDENT (',' l+=IDENT)*
        { for (Token val : $l) { System.out.println(val); }};
</div></code></pre>
<p>Ejemplo con no-terminales:</p>
<pre class="hljs"><code><div>a: l+=expr (',' l+=expr)*
        { for (ExprContext ctx : $l) { System.out.println(ctx.ast); }};
</div></code></pre>
<p>Usando esto, se podría hacer el ejemplo de la versión simple de la siguiente manera:</p>
<pre class="hljs"><code><div>start returns[Program ast]
	: 'CODE' ls+=sentence* { $ast = new Program($ls); }
	;

sentence returns[Sentence ast]
	: 'print' expr ';'	{ $ast = new Print($expr.ast); }
	| expr '=' expr ';'	{ $ast = new Assignment($ctx.expr(0), $ctx.expr(1)); }
	;
</div></code></pre>
<p>Nótese que el no-terminal <code>sentences</code> ya no es necesario para introducir la repetición, ya que la lista de sentencias se puede hacer directamente en la regla padre <code>start</code>. La lista que ANTLR ha creado es de objetos <code>SentenceContext</code>, por lo que es posible que, antes de meterla en el AST, se prefiera recorrer dicha lista en la regla <code>start</code> y extraer el atributo <code>ast</code> de cada elemento para pasarselo al constructor del <code>Programa</code>. En el ejemplo anterior, se está suponiendo que esto lo hará el constructor de dicha clase.</p>
<p>Por tanto, las ventajas de este enfoque frente a la versión simple son:</p>
<ul>
<li>Permite sustituir los patrones BNF por los operadores EBNF de repetición ('+' y '*').</li>
<li>Se evita así tener que escribir el código Java para añadirlos a una lista.</li>
<li>Permite unas reglas más limpias al tener todo el código Java al final de las mismas (y no intercaladas entre los símbolos).</li>
</ul>

</body>
</html>
